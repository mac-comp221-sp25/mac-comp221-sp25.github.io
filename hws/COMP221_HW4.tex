\documentclass{exam}
\usepackage{graphicx} % Required for inserting images
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{geometry}[border=1in]
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{hyperref}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newtheoremstyle{prob}% name 
{7pt}% Space above 
{7pt}% 
{}% 
{0pt}%Indent amount 1 
{\bfseries}% Theorem head font 
{.}% 
{\newline}% 
{}%

\theoremstyle{prob}
\newtheorem*{probstate}{PROBLEM}

\printanswers

\title{Homework 4}
\author{COMP221 Spring 2025 - Suhas Arehalli}
\date{}

\begin{document}

\maketitle

Complete the problems below. Check the course website \& syllabus for further instructions.

If any problem is unclear, or you think you found a typo, please let me know ASAP so I can clarify!

\section*{Problems}

\begin{questions}
    \question \textbf{Making Change} 
    
    Suppose you are a cashier making change for a customer. Consider the following problem description for the problem of providing change with the fewest number of coins:
    \begin{probstate}[Minimal Change Set]
        \textbf{Input:} $k \in \mathbb{Z}$, a number of cents, and $C = \{c_1, \dots c_n\} \subseteq \mathbb{Z}_+$. 
        
        \textbf{Output:} A multi-set (set that allows duplicates) $L$ such that 
        \begin{itemize}
            \item $\forall c \in L, c \in C$
            \item $\sum_{c \in L} c = k$
            \item $\lvert L \rvert$ is minimized.
        \end{itemize}
        if such a set exists. $NULL$ otherwise.
    \end{probstate}
    That is, I need you to find the fewest possible coins such that the values of those coins add up to $k$. 

    You might have seen in Discrete Math that a greedy strategy works for US coin denominations (i.e., the case where $C = \{1, 5, 10, 25\}$. In fact, you can prove this correct using a clever, but tedious exchange argument.
    \begin{parts}
        
        \part Prove via counterexample that the greedy strategy will not work for all sets of coin denominations $C$. That is, construct $C$ such that the greedy approach fails to find the minimal choice of coins.

        \part Describe the solution to this problem in terms of a recurrence relation. For simplicity, write a solution that finds the \textbf{size} of the optimal set rather than constructing the set itself.

        \textit{**HINT**:} Think carefully about how to frame the problem as a sequential decision process. It may be helpful to think about a way to avoid the mistake a greedy algorithm makes on your counterexample in the prior part, or to consider the subset sum problem.

        \part Provide pseudocode for a dynamic programming algorithm that computes the \textbf{minimum number of coins} needed to make $k$ units of change that works for \textit{any} coin system. For full points, provide a solution that runs in $O(k\lvert C \rvert)$ time and $O(k)$ space. A solution with a worse space complexity can still get the majority of points.

    \end{parts}
    \question \textbf{Degree-Constrained Spanning Trees} \textit{(Based on Skiena 11-12)}
    

    \begin{parts}
        \part The low-degree spanning tree problem (\textproc{Low-Degree-Span}) is a decision problem defined as follows:
        \begin{probstate}[\textproc{Low-Degree-Span}]
            \textbf{Input:} An undirected graph $G = (V, E)$ and $k \in \mathbb{Z}_{\geq 0}$
        
            \textbf{Output:} TRUE iff there exists a spanning tree where each vertex in the tree has degree $\leq k$. FALSE otherwise.
        \end{probstate}
        Prove (using a Karp reduction) that \textproc{Low-Degree-Span} is NP-hard. Make sure you provide both a description of the reduction and a brief justification of the correctness of the reduction as part of your answer.

        \textbf{**Hint**:} Skim through the NP-hard problems we've seen so far and see which ones seem most similar. Then try and construct a reduction in the appropriate direction.

        
        \part Consider the \textit{high-degree spanning tree problem} (\textproc{High-Degree-Span}) which is defined as follows:
        \begin{probstate}[\textproc{High-Degree-Span}]
            \textbf{Input:} An undirected graph $G = (V, E)$ and $k \in \mathbb{Z}_{\geq 0}$.
            
            \textbf{Output:} TRUE if $G$ contains a spanning tree which contains a vertex with degree $\geq k$ (within the spanning tree). FALSE otherwise.
        \end{probstate} 
        Show that \textproc{High-Degree Span} is in P by providing pseudocode for a polynomial-time algorithm to solve this problem. 

        \textbf{**Hint**}: Consider methods we've seen before that have you construct spanning trees in a graph!
        
    \end{parts}
\end{questions}

\end{document}